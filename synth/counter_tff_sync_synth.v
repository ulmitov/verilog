/* Generated by Yosys 0.59+134 (git sha1 07a690570, clang++ 18.1.8 -fPIC -O3) */

module counter_tff_sync(clk, res_n, en, count_up, count);
  input clk;
  wire clk;
  input res_n;
  wire res_n;
  input en;
  wire en;
  input count_up;
  wire count_up;
  output [2:0] count;
  wire [2:0] count;
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire [2:0] en_and;
  assign en_and[1] = en & _2_;
  assign en_and[2] = en_and[1] & _3_;
  assign _0_ = ~ count[0];
  assign _1_ = ~ count[1];
  assign _2_ = count_up ? count[0] : _0_;
  assign _3_ = count_up ? count[1] : _1_;
  ff_t ff_0 (
    .Q(count[0]),
    .T(en),
    .clk(clk),
    .res_n(res_n)
  );
  ff_t \genblk1[1].ff_i  (
    .Q(count[1]),
    .T(en_and[1]),
    .clk(clk),
    .res_n(res_n)
  );
  ff_t \genblk1[2].ff_i  (
    .Q(count[2]),
    .T(en_and[2]),
    .clk(clk),
    .res_n(res_n)
  );
  assign en_and[0] = en;
endmodule

module ff_t(clk, res_n, T, Q);
  input clk;
  wire clk;
  input res_n;
  wire res_n;
  input T;
  wire T;
  output Q;
  reg Q;
  wire _0_;
  always @(posedge clk, negedge res_n)
    if (!res_n) Q <= 1'h0;
    else if (T) Q <= _0_;
  assign _0_ = ~ Q;
endmodule
