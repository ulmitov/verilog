/* Generated by Yosys 0.59+134 (git sha1 07a690570, clang++ 18.1.8 -fPIC -O3) */

module counter_jkff(clk, res_n, en, count_up, count);
  input clk;
  wire clk;
  input res_n;
  wire res_n;
  input en;
  wire en;
  input count_up;
  wire count_up;
  output [2:0] count;
  wire [2:0] count;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire J;
  wire K;
  wire [2:0] d;
  wire [2:0] j;
  wire [2:0] k;
  assign J = en & res_n;
  assign d[1] = en & _04_;
  assign d[2] = d[1] & _05_;
  assign _00_ = J != K;
  assign _01_ = ~ res_n;
  assign _02_ = ~ count[0];
  assign _03_ = ~ count[1];
  assign K = en | _01_;
  assign _04_ = count_up ? count[0] : _02_;
  assign _05_ = count_up ? count[1] : _03_;
  assign j[0] = _00_ ? J : en;
  assign j[1] = _00_ ? J : d[1];
  assign j[2] = _00_ ? J : d[2];
  assign k[0] = _00_ ? K : en;
  assign k[1] = _00_ ? K : d[1];
  assign k[2] = _00_ ? K : d[2];
  ff_jk \genblk1[0].ff  (
    .J(j[0]),
    .K(k[0]),
    .Q(count[0]),
    .clk(clk)
  );
  ff_jk \genblk1[1].ff  (
    .J(j[1]),
    .K(k[1]),
    .Q(count[1]),
    .clk(clk)
  );
  ff_jk \genblk1[2].ff  (
    .J(j[2]),
    .K(k[2]),
    .Q(count[2]),
    .clk(clk)
  );
  assign d[0] = en;
endmodule

module ff_jk(clk, J, K, Q);
  input clk;
  wire clk;
  input J;
  wire J;
  input K;
  wire K;
  output Q;
  reg Q;
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  always @(posedge clk)
    if (!_05_) Q <= _00_;
  assign _01_ = ~ Q;
  function [0:0] _08_;
    input [0:0] a;
    input [2:0] b;
    input [2:0] s;
    casez (s) // synopsys parallel_case
      3'b??1:
        _08_ = b[0:0];
      3'b?1?:
        _08_ = b[1:1];
      3'b1??:
        _08_ = b[2:2];
      default:
        _08_ = a;
    endcase
  endfunction
  assign _00_ = _08_(1'hx, { 2'h1, _01_ }, { _04_, _03_, _02_ });
  assign _02_ = { J, K } == 2'h3;
  assign _03_ = { J, K } == 2'h2;
  assign _04_ = { J, K } == 1'h1;
  assign _05_ = ! { J, K };
endmodule
